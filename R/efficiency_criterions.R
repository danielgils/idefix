

#' D-error
#'
#' Function to calculate d error given a design, and parameter values.
#' @param par Vector containing parameter values.
#' @param des A design matrix in which each row is a profile.
#' @param n.alts Numeric value indicating the number of alternatives per choice set.
#' @return D-error.
#' @export
Derr <- function(par, des, n.alts) {
  info.des <- InfoDes(par, des, n.alts)
  detinfo <- det(info.des)
  ifelse((detinfo <= 0), return(NA), return(detinfo^(-1 / length(par))))
}


#' Fisher Information of design
#'
#' Returns the Fisher Information of a design, given parameter values
#' @param par A vector containing the parameter values
#' @param des A design matrix in which each row is a profile.
#' @param n.alts Numeric value indicating the number of alternatives per choice set.
#' @return Fisher Information matrix.
InfoDes <- function(par, des, n.alts) {
  group <- rep(seq(1, nrow(des) / n.alts, 1), each = n.alts)
  # probability
  u <- des %*% diag(par)
  u <- .rowSums(u, m = nrow(des), n = length(par))
  p <- exp(u) / rep(rowsum(exp(u), group), each = n.alts)
  # information matrix
  info.des <- crossprod(des * p, des) - crossprod(rowsum( des * p, group))
  return(info.des)
}


#' Utility balance 
Utbal <- function(par, des, n.alts) { 
  group <- rep(seq(1, nrow(des) / n.alts, 1), each = n.alts)
  u <- des %*% diag(par)
  u <- .rowSums(u, m = nrow(des), n = length(par))
  p <- exp(u) / rep(rowsum(exp(u), group), each = n.alts)
  ub <- by(p, group, function(x) {max(x) - min(x)}, simplify = TRUE)
  # return
  return(ub)
}

#' KL information
#'
#' Calculates the Kullback-Leibler divergence for a choice set, given parameter values.
#' @param set Numeric matrix in which each row is a profile.
#' @param par.samples A matrix in which each row is a sample.
#' @param weights A vector containing the weights of the samples.
#' @return The Kullback-Leibler divergence.
#' @export
KL <- function (set, par.samples, weights){
  
  #probability
  num<-set%*%t(par.samples)
  mmat<-as.matrix(t(apply(num[, 1:ncol(num)], 2, max)))
  nummax<-exp(sweep(num, MARGIN=2, mmat, FUN="-"))
  denom<-colSums(nummax)
  
  probs<-sweep(nummax, MARGIN=2, denom, FUN="/")
  logprobs<-log(probs)
  
  wprob<- sweep(probs, MARGIN=2, weights, FUN="*")
  totwprob<- rowSums(wprob)
  
  logwprob<- sweep(logprobs, MARGIN=2, weights, FUN="*")
  totlogwprob<- rowSums(logwprob)
  
  #kullback Leibler information
  klinfo<- 0
  for( a in 1:n.alts){
    klinfo<- klinfo + (totwprob[a] * (log(totwprob[a]) - totlogwprob[a]))
  }
  
  return (as.numeric(klinfo))
}


#' Kullback-Leibler information criterion
#'
#' Calcultates the most effecient choice set by maximizing the Kullback-Leibler distance.
#' @param fp A Matrix containing every possible profile (combination of attributelevels). Can be generated by using the "profiles" function.
#' @param fcomb A matrix containing in each row the to be considered profile combinations (choice sets). Can be generated by using the "full_sets" function.
#' @param par.samples A matrix in which each row is a sample from a multivariate parameter distribution.
#' @param weights A vector containing the weights of all the samples.
#' @param n.alts Numeric value indicating the number of alternatives per choice set.
#' @param print Logical statement indicating whether to print the KL information or not.
#' @return The most efficient choice set, based on the KL information criterion.
#' @export
KL_info<-function (fp, fcomb, par.samples, weights, n.alts, print=FALSE){

  minKL <- 0
  new_set<-numeric()

  for (s in 1:nrow(fcomb)) {

    set <- fp[as.numeric(fcomb[s,]), ]
    num <- tcrossprod(par.samples, set)
    expnum<-exp(num)
    total<-rowSums(expnum)
    probs<-expnum / total
    totwprob <- t(probs) %*% weights
    logprobs <- log(probs)
    totlogwprob <- t(logprobs) %*% weights

    klinfo <- 0

    for (a in 1:n.alts) {
      klinfo <- klinfo + (totwprob[a] * (log(totwprob[a]) - totlogwprob[a]))
    }

    if (klinfo > minKL) {
      minKL <- klinfo
      new_set <- set
      if(print){print(klinfo)}
    }
  }
  return(new_set)
}






