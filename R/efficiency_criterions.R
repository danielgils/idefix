

#' D-error
#'
#' Function to calculate d error given a design, and parameter values.
#' @param par Vector containing parameter values.
#' @param des A design matrix in which each row is a profile.
#' @param n.alts Numeric value indicating the number of alternatives per choice set.
#' @return D-error.
Derr <- function(par, des, n.alts) {
  info.des <- InfoDes(par, des, n.alts)
  detinfo <- det(info.des)
  ifelse((detinfo <= 0), return(NA), return(detinfo^(-1 / length(par))))
}

#' Sequential D-error
#' 
#' Function to calculate D-errors if set would be part of design. 
#' @inheritParams Modfed
#' @param set A choice set in which each row is a profile.
#' @param des A design matrix in which each row is a profile.
#' @param i.cov Inverse of covariance matrix.  
#' @param n.par Number of parameters.
DerrS <- function(par.samples, set, des, n.alts, i.cov, n.par) {
  des.f <- rbind(des, set) 
  info.d <- InfoDes(par = par.samples, des = des.f, n.alts = n.alts) 
  d.error <- det(info.d + i.cov)^(-1 / n.par)
  return(d.error)
}

#' Sequential DB-error
#' 
#' Function to calculate DB-errors for potential choice sets in combination with
#' an initial design.
#' @inheritParams Modfed
#' @inheritParams DerrS
#' @param full.comb A matrix with on each row a possible combination of
#'   profiles.
#' @param cte.des A matrix which represent the alternative specific constants. 
#'   If there are none it value is \code{NULL}.
#' @return The DB errors of the designs in which each design is a combination
#'   with of the initial design with a potential choice set.
DBerrS <- function(full.comb, cand.set, par.samples, des, n.alts, cte.des, i.cov, n.par, weights) {
  # Take set.
  set <- as.matrix(cand.set[as.numeric(full.comb), ])
  # Add alternative specific constants if necessary
  if (!is.null(cte.des)) {
    set <- as.matrix(cbind(cte.des, set))
  }
  # For each draw calculate D-error.
  d.errors <- apply(par.samples, 1, DerrS, set, des, n.alts, i.cov, n.par)
  w.d.errors <- d.errors * weights
  # DB-error. 
  db.error <- mean(w.d.errors, na.rm = TRUE)
  return(db.error)
}


#' Fisher Information of design
#'
#' Returns the Fisher Information of a design, given parameter values.
#' @inheritParams Modfed
#' @param par A vector containing the parameter values
#' @return Fisher Information matrix.
InfoDes <- function(par, des, n.alts) {
  group <- rep(seq(1, nrow(des) / n.alts, 1), each = n.alts)
  # probability
  u <- des %*% diag(par)
  u <- .rowSums(u, m = nrow(des), n = length(par))
  p <- exp(u) / rep(rowsum(exp(u), group), each = n.alts)
  # information matrix
  info.des <- crossprod(des * p, des) - crossprod(rowsum( des * p, group))
  return(info.des)
}


#' Utility balance 
Utbal <- function(par, des, n.alts) { 
  group <- rep(seq(1, nrow(des) / n.alts, 1), each = n.alts)
  u <- des %*% diag(par)
  u <- .rowSums(u, m = nrow(des), n = length(par))
  p <- exp(u) / rep(rowsum(exp(u), group), each = n.alts)
  ub <- by(p, group, function(x) {max(x) - min(x)}, simplify = TRUE)
  # return
  return(ub)
}

#' KL information
#'
#' Calculates the Kullback-Leibler divergence for a choice set, given parameter values.
#' @param set Numeric matrix in which each row is a profile.
#' @param par.samples A matrix in which each row is a sample.
#' @param weights A vector containing the weights of the samples.
#' @return The Kullback-Leibler divergence.
#' @export
KL <- function (set, par.samples, weights){
  
  #probability
  num<-set%*%t(par.samples)
  mmat<-as.matrix(t(apply(num[, 1:ncol(num)], 2, max)))
  nummax<-exp(sweep(num, MARGIN=2, mmat, FUN="-"))
  denom<-colSums(nummax)
  
  probs<-sweep(nummax, MARGIN=2, denom, FUN="/")
  logprobs<-log(probs)
  
  wprob<- sweep(probs, MARGIN=2, weights, FUN="*")
  totwprob<- rowSums(wprob)
  
  logwprob<- sweep(logprobs, MARGIN=2, weights, FUN="*")
  totlogwprob<- rowSums(logwprob)
  
  #kullback Leibler information
  klinfo<- 0
  for( a in 1:n.alts){
    klinfo<- klinfo + (totwprob[a] * (log(totwprob[a]) - totlogwprob[a]))
  }
  
  return (as.numeric(klinfo))
}


#' Kullback-Leibler information criterion
#'
#' Calcultates the most effecient choice set by maximizing the Kullback-Leibler distance.
#' @param fp A Matrix containing every possible profile (combination of attributelevels). Can be generated by using the "profiles" function.
#' @param fcomb A matrix containing in each row the to be considered profile combinations (choice sets). Can be generated by using the "full_sets" function.
#' @param par.samples A matrix in which each row is a sample from a multivariate parameter distribution.
#' @param weights A vector containing the weights of all the samples.
#' @param n.alts Numeric value indicating the number of alternatives per choice set.
#' @param print Logical statement indicating whether to print the KL information or not.
#' @return The most efficient choice set, based on the KL information criterion.
#' @export
KL_info<-function (fp, fcomb, par.samples, weights, n.alts, print=FALSE){

  minKL <- 0
  new_set<-numeric()

  for (s in 1:nrow(fcomb)) {

    set <- fp[as.numeric(fcomb[s,]), ]
    num <- tcrossprod(par.samples, set)
    expnum<-exp(num)
    total<-rowSums(expnum)
    probs<-expnum / total
    totwprob <- t(probs) %*% weights
    logprobs <- log(probs)
    totlogwprob <- t(logprobs) %*% weights

    klinfo <- 0

    for (a in 1:n.alts) {
      klinfo <- klinfo + (totwprob[a] * (log(totwprob[a]) - totlogwprob[a]))
    }

    if (klinfo > minKL) {
      minKL <- klinfo
      new_set <- set
      if(print){print(klinfo)}
    }
  }
  return(new_set)
}






